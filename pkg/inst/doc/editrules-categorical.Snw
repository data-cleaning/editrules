%\VignetteIndexEntry{Categorical edit manipulation and error localization with the editrules package}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb}
\usepackage{threeparttable}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\res}{\mathfrak{R}}
\newcommand{\rhomap}{\xrightarrow{\rho}}

\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t}{rco}
\floatname{Rcode}{Figure}
 


% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}
\hyphenation{time-stamp}

<<echo=false>>=
library(editrules)
@

\title{Manipulation of categorical and mixed data edits and error localization with the {\tt editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Mark van der Loo and Edwin de Jonge}
\begin{document}
\maketitle
\begin{abstract}
{\em This vignette is far from finished. Version 2.0 fo the package will have
the full vignette. At the moment, functionality for treating categorical data has alpha status and is not public yet.}
\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Introduction}


\section{Defining and checking categorical constraints}
We spend some time to define the boolean representation, since it eventually allow for an elegant
elimination method.
\subsection{The {\tt editarray} object}
A categorical record ${\bf v}$ is a combination of values from the
cartesian product space
\begin{equation}
    D = D_1\times D_2\times\ldots\times D_n,
\end{equation}
where each $D_k$ is a finite set of $d_k$ categories. The total number of
categories is $d = \sum_{k=1}^n d_k$.
Categorical records can be represented as  a boolean vector. A boolean
vector of dimension $d$ is an element of the boolean algebra 
\begin{equation}
\mathbb{B}^{d}=\left(\{0,1\}^{d},\land,\lor,\lnot\right),
\end{equation}
where 0 and 1 have the usual interpretations {\sc false} and {\sc true} and the
logical operators work elementwise on their operands. To represent a record
${\bf v}$, assign to every category $i$ in $D_k$ a unique standard 
basisvector $\vec{\delta}_k(i)$ of $\mathbb{B}^{d_k}$. 
The boolean representation $\rho({\bf v})$ of the full record reads
%
\begin{equation}
    {\bf v} \xrightarrow{\rho} \vec{\delta}_{1}(v_1)\oplus\vec{\delta}_{2}(v_2)\oplus\ldots\oplus\vec{\delta}_n(v_n).
\end{equation}
An edit $e$ is a subset of $D$, which can be written as the cartesian product
\begin{equation}
    e = {\bf e}_1\times{\bf e}_2\ldots\times{\bf e}_n,
\end{equation}
where each ${\bf e}_k\subseteq D_k$.  The interpretation of an edit is that if
a record ${\bf v}\in e$, then ${\bf v}$ is considered invalid.  We say that a
record {\em fails} an edit when it satisfies Eq.\ \eqref{eqCheckEdit}.  A
variable $v_i$ is {\em involved} in an edit if ${\bf e}_i\subset D_j$ is a
proper subset.  Conversely, we say that $e$ contains $v_k$ if $v_k$ is involved
in $e$. A variable for which ${\bf e}_k=D_k$ is not contained in $e$.

Since every category $i$ of $D_k$ is mapped to a unique basis vector
$\vec{\delta}_k(i)$,  edits have a boolean representation $\rho(e)$, given by
\begin{eqnarray}
    e &\xrightarrow{\rho}&
    \Lor_{i\in{\bf e}_1}\vec{\delta}_1(i)\oplus
    \Lor_{i\in{\bf e}_2}\vec{\delta}_2(i)\oplus\ldots
    \oplus\Lor_{i\in{\bf e}_k}\vec{\delta}_n(i),
\end{eqnarray}
which may simply be written as
\begin{equation}
    \rho(e) ={\bf a} = {\bf a}_1\oplus{\bf a}_2\oplus\ldots\oplus{\bf a}_n.
\label{EqRhoE}
\end{equation}
One may think of the ${\bf a}_k$ as boolean vectors indicating which elements of $D_k$
occur in ${\bf e}_k$.

In the {\tt editrules} package, a set of categorical edits is represented as an {\tt editarray}
object. Formally, we denote an edit array $E$ for $n$ categorical variables and $m$ edits as
\begin{equation}
    E = \langle {\bf A}\rangle\textrm{, with }{\bf A}\in\{0,1\}^{m\times d}\textrm{ and }
    d = \sum_{k=1}^n d_k.
    \label{eqEditarray}
\end{equation}
Here, each row of ${\bf A}$ contains the boolean representation of one edit,
and the $d_k$ denote the number of categories of each variable. The brackets
are used to indicate a combination of objects. The {\tt editarray} is the
central object for computing with catgegorical edits, just like the {\tt
editmatrix} is the central object for computations with linear edits.
 
%
\begin{Rcode}
<<keep.source=true>>=
#editarray(c(
#    "gender %in% c('male','female')",
#    "pregnant %in% c('yes','no')",
#    "if (gender == 'male') pregnant == 'no'"
#    )
#)
@
\caption{Defining a simple {\tt editarray} with the {\tt editarray} function. 
Column heads of the array are abbreviated versions of variable names and categories
seperated by a colon (by default). When printed to screen, a {\tt character} version
of the edits is shown as well, for readability.
}
\label{Reditarray}
\end{Rcode}
%

It is both tedious and error prone to define and maintain an editarray by hand.
In practice, categorical edits are usually stated verbosely, such as: ``if the
gender is male, then pregnant must be false'', or ``if you are under-aged, you
cannot be married''. To facilitate the definition of edit arrays, {\tt
editrules} is equipped with a parser, which takes R-statements in {\tt
character} format, and translates them to an {\tt editarray}.

Figure \ref{Reditarray} shows a simple example of defining an editmatrix with
the editrules package.  The first two edits in Figure \ref{Reditarray} define
the data model. The {\tt editarray} function derives the datamodel based on the
variable names and categories it finds in the edits, whether they are
univariate (defining domains) of multivariate. This means that if all possible
variables and categories are mentioned in the multivariate edits, the correct
datamodel will be derived as well. It is important to note that most functions
working with categorical edits, assume that the full datamodel is represented
in the columns of an {\tt editarray}. The function {\tt datamodel} accepts an
edit array as input and returns an overview of variables and their categories.

When printed to the screen, the boolean array is shown with column heads of the form
\begin{quote}
{\tt <variable><separator><category>}, 
\end{quote}
where both variable names and categories are abbreviated for readability, and
the standard separator is a colon ({\tt :}). The separator may not occur as a
symbol in either variable or category name, and its value can be determined by
passing a custom {\tt sep} argument to {\tt editarray}.

Internally, {\tt editarray} uses the {\sf R} internal {\tt parse} function to
transform the {\tt character} expressions to a parse tree, which is
subsequently traversed recursively to derive the entries of the editmatrix. The
opposite is also possible. The {\sf R} internal function {\tt as.character} has
been overloaded to derive a {\tt character} representation from a boolean
representation. When printed to the screen, both the boolean and textual
representation are shown.

The character expressions that can be read by {\tt editarray}, such as
\begin{quote}
\verb+"if ( gender == 'male' ) pregnant = 'no'"+ 
\end{quote}
follows standard {\sf R} syntax, which should be already familliar to the
reader. Note that double quotes are used to enclose the whole string, while
single quotes are used for category names. Table \ref{tabOperators} shows
which operators and functions can be used to specify categorical edit rules.
%
\begin{table}
\begin{threeparttable}
\caption{Functions and operators that may be used to define edits with {\tt editarray} }
\label{tabOperators}
\begin{tabular}{ll}
\hline
Operator & Description\\
\hline
{\tt \%in\%} & Set membership$^*$  \\
{\tt ==}     & Equality$^*$ \\
{\tt if( <condition> ) <expression> } & conditional statement\\
{\tt c(\verb"'"<cat1>\verb"'",\verb"'"<cat2>\verb"'",...)} & categories, {\tt character} or {\tt logical}\\
{\tt \&\&}    & logical {\sc and}\\
{\tt ||}      & logical {\sc or}\\
{\tt !}       & logical {\sc not}\\
\hline
\end{tabular}
$^*${\small Right-hand side is evaluated.}
\end{threeparttable}
\end{table}
%
%
Categories may be litaral characters, or booleans.  It is worth noting that
expressions on the right hand side of the {\tt \%in\%}  and {\tt ==} operators
are evaluated. One useful application of this is that the categories, or data
model can be defined outside of the edits:
%
<<keep.source=true>>=
#xval <- letters[1:4]
#yval <- c(TRUE,FALSE)
#editarray(c( "x %in% xval","y %in% yval","if ( x %in% c('a','b') ) !y "))
@
%
The above example also illustrates the use of boolean categories.



\subsection{Basic manipulations and edit checking}
Table \ref{tabBasicfunctions} shows lists basic functions of {\tt editmatarray}
objects.  The {\tt datamodel} function retrieves the variables and categories
in an edit array, and returns them as a two-column {\tt data.frame}.

With {\tt getArr} the array part of an {\tt editarray} can be retrieved. The
other contents of an {\tt editarrray} are of no use for users and are {\tt
editrules} internal.

The function {\tt violatedEdits} takes a {\tt data.frame} or named {\tt
character} vector as input and returns a logical array where each row indicates
which edits are violated by the input data.
The relation 
\begin{equation}
    {\bf v}\in{e}\Leftrightarrow \sum_{j=1}^d(\rho({\bf v})\land\rho({ e}))_j = n,
    \label{eqCheckEdit}
\end{equation}
is used to test the validity of records. Here, $n$ is the number of variables
and the sum is over the coefficients of $\rho({\bf v})\land\rho({ e})$,
interpreted as numbers. The relation holds since a record can have at most one
coefficient per variable equal to $1$ in the boolean representation.




\begin{table}
\begin{threeparttable}
\caption{Basic functions for objects of class {\tt editarray}. Only mandatory
arguments are shown, refer to the built-in documentation for optional
arguments.}
\label{tabBasicfunctions}
\begin{tabular}{ll}
\hline
Function        & description \\
\hline
{\tt datamodel(E)}           & get datamodel \\
{\tt getArr}                 & get array ${\bf A}$\\
{\tt as.data.frame(E)}       & coerce to {\tt data.frame}\\
{\tt as.character(E)}        & coerce to {\tt character} vector\\
{\tt violatedEdits(E,x)}     & check which edits are violated by {\tt x}\\
{\tt duplicated(E)}          & detect duplicate edits\\
{\tt isObviouslyRedundant(E)}& detect simple redundancies\\
{\tt isSubset(E)}            & detect edits contained in another edit\\
{\tt isObviouslyInfeasible}  & detect if {\tt E} contains a contradiction\\ 
{\tt substValue}             & substitute a value\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}


\subsection{Obvious redundancy and infeasibility}
When manipulating edit sets, edits may arise which have ${\bf e}_k=\varnothing$
for one of the variables. A record can never be an element of such an edit, and
such edits are therefore redundant. Such redundancies are easily detected since
all coefficients of the corresponding ${\bf a}_k$ (Eq.\ \eqref{EqRhoE}) are
equal to zero for these edits. The function {\tt isObviouslyRedundant} returns
a logical vector indicating which edits in an editarray have become obviously
redundant.  If an edit is a subset of another edit, it is also redundant. The
function {\tt isSubset} returns a logical, indicating if an edit is a subset of
any other edit in the {\tt editarray}.

Manipulations may also lead to edits of the form $e=D$, in which case every possible
record is invalid, and the editarray has become impossible to satisfy. The function
{\tt isObviouslyInfeasible} detects whether any such edits are present.They can be 
detected by checking if $\sum_{j=1}^d\rho(e)_j=d$.


\section{Manipulation of categorical restrictions}

\subsection{Value substitution}
Substituting a value in an editarray consists of two steps. First, all edits
that exclude the value which is to be subsituted are removed. They have become
redundant, since no record can be contained in such edits. Second, if variable
$k$ is substituted by category $j\in D_k$, for every remaining edit, all
coefficients of ${\bf a}_k$ except the $j$th are set to 0.  The function {\tt
substValue} can be used to substitute one or more values in an {\tt editarray}.



\subsection{Variable elimination by category resolution}
Suppose $e_1$ and $e_2$ are edits, with boolean representations ${\bf a}$ and ${\bf b}$ respectively.
We define the {\em resolution operator} $\res_j$ as follows:
\begin{eqnarray}
    {\bf a} \res_j {\bf b} = (a_1\land b_1,\ldots,a_{j-1}\land b_{j-1},a_{j}\lor b_{j},a_{j+1}\land b_{j+1},\ldots,a_d\land b_d). 
\end{eqnarray}
Observe that if a record ${\bf v}\in {\bf a}\res_j{\bf b}$, it must hold that
${\bf v}\in e_1$ and/or ${\bf v}\in e_2$.  The converse is also true: If ${\bf
v}\in e_1$ or $e_2$, then it must be in $e_1\res_j e_2$.  The operator is
called resolution operator since its action strongly resembles a resolution
operation from formal logic.  If $a_j= \lnot b_j$, the operator ``resolves'' or
eliminates one of the categories $j\in D$. If $a_j=b_j$, the resulting edit is
the intersection of the original edits.

Given the boolean vectors {\bf a}, {\bf b} and {\bf c} in $\mathbb{B}^d$. It is
not difficult to show that the resolution operator has the following properties 
\begin{equation}
\begin{array}{ll}
\textrm{symmetry:}  &{\bf a}\res_j{\bf b} = {\bf b} \res_j {\bf a} \\
\textrm{associativity:}& ({\bf a}\res_j{\bf b})\res_j {\bf c} = {\bf a}\res_j({\bf b}\res_j {\bf c})\\
\textrm{idempotency:} &{\bf a}\res_j {\bf a} = {\bf a}.
\end{array}
\end{equation}
The following distributive property also holds
\begin{equation}
\begin{array}{ll}
\textrm{distributivity:}& ({\bf a}\res_i{\bf b})\res_j{\bf c} = ({\bf a}\res_j{\bf c})\res_i({\bf b}\res_j{\bf c}).
\end{array}
\end{equation}







\bibliographystyle{chicago}
\bibliography{editrules}

\end{document}
